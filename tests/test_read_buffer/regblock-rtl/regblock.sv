// Generated by PeakRDL-regblock - A free and open-source SystemVerilog generator
//  https://github.com/SystemRDL/PeakRDL-regblock

module regblock (
        input wire clk,
        input wire rst,

        input wire s_apb_psel,
        input wire s_apb_penable,
        input wire s_apb_pwrite,
        input wire [2:0] s_apb_pprot,
        input wire [4:0] s_apb_paddr,
        input wire [7:0] s_apb_pwdata,
        input wire [0:0] s_apb_pstrb,
        output logic s_apb_pready,
        output logic [7:0] s_apb_prdata,
        output logic s_apb_pslverr,

        input regblock_pkg::regblock__in_t hwif_in,
        output regblock_pkg::regblock__out_t hwif_out
    );

    //--------------------------------------------------------------------------
    // CPU Bus interface logic
    //--------------------------------------------------------------------------
    logic cpuif_req;
    logic cpuif_req_is_wr;
    logic [4:0] cpuif_addr;
    logic [7:0] cpuif_wr_data;
    logic [7:0] cpuif_wr_biten;
    logic cpuif_req_stall_wr;
    logic cpuif_req_stall_rd;

    logic cpuif_rd_ack;
    logic cpuif_rd_err;
    logic [7:0] cpuif_rd_data;

    logic cpuif_wr_ack;
    logic cpuif_wr_err;

    // Request
    logic is_active;
    always_ff @(posedge clk) begin
        if(rst) begin
            is_active <= '0;
            cpuif_req <= '0;
            cpuif_req_is_wr <= '0;
            cpuif_addr <= '0;
            cpuif_wr_data <= '0;
            cpuif_wr_biten <= '0;
        end else begin
            if(~is_active) begin
                if(s_apb_psel) begin
                    is_active <= '1;
                    cpuif_req <= '1;
                    cpuif_req_is_wr <= s_apb_pwrite;
                    cpuif_addr <= s_apb_paddr[4:0];
                    cpuif_wr_data <= s_apb_pwdata;
                    for(int i=0; i<1; i++) begin
                        cpuif_wr_biten[i*8 +: 8] <= {8{s_apb_pstrb[i]}};
                    end
                end
            end else begin
                cpuif_req <= '0;
                if(cpuif_rd_ack || cpuif_wr_ack) begin
                    is_active <= '0;
                end
            end
        end
    end

    // Response
    assign s_apb_pready = cpuif_rd_ack | cpuif_wr_ack;
    assign s_apb_prdata = cpuif_rd_data;
    assign s_apb_pslverr = cpuif_rd_err | cpuif_wr_err;

    logic cpuif_req_masked;

    // Read & write latencies are balanced. Stalls not required
    assign cpuif_req_stall_rd = '0;
    assign cpuif_req_stall_wr = '0;
    assign cpuif_req_masked = cpuif_req
                            & !(!cpuif_req_is_wr & cpuif_req_stall_rd)
                            & !(cpuif_req_is_wr & cpuif_req_stall_wr);

    //--------------------------------------------------------------------------
    // Address Decode
    //--------------------------------------------------------------------------
    typedef struct {
        logic [3:0] reg1;
        logic [3:0] reg1_msb0;
        logic [3:0] reg2;
        logic g1_r1;
        logic g1_r2;
        logic [1:0] g2_r1;
        logic [1:0] g2_r2;
        logic g3_r1;
        logic g3_r2;
        logic g4_trig;
        logic g4_r1;
        logic g4_r2;
    } decoded_reg_strb_t;
    decoded_reg_strb_t decoded_reg_strb;
    logic decoded_req;
    logic decoded_req_is_wr;
    logic [7:0] decoded_wr_data;
    logic [7:0] decoded_wr_biten;

    always_comb begin
        decoded_reg_strb.reg1[0] = cpuif_req_masked & (cpuif_addr == 5'h0);
        decoded_reg_strb.reg1[1] = cpuif_req_masked & (cpuif_addr == 5'h1);
        decoded_reg_strb.reg1[2] = cpuif_req_masked & (cpuif_addr == 5'h2);
        decoded_reg_strb.reg1[3] = cpuif_req_masked & (cpuif_addr == 5'h3);
        decoded_reg_strb.reg1_msb0[0] = cpuif_req_masked & (cpuif_addr == 5'h4);
        decoded_reg_strb.reg1_msb0[1] = cpuif_req_masked & (cpuif_addr == 5'h5);
        decoded_reg_strb.reg1_msb0[2] = cpuif_req_masked & (cpuif_addr == 5'h6);
        decoded_reg_strb.reg1_msb0[3] = cpuif_req_masked & (cpuif_addr == 5'h7);
        decoded_reg_strb.reg2[0] = cpuif_req_masked & (cpuif_addr == 5'h8);
        decoded_reg_strb.reg2[1] = cpuif_req_masked & (cpuif_addr == 5'h9);
        decoded_reg_strb.reg2[2] = cpuif_req_masked & (cpuif_addr == 5'ha);
        decoded_reg_strb.reg2[3] = cpuif_req_masked & (cpuif_addr == 5'hb);
        decoded_reg_strb.g1_r1 = cpuif_req_masked & (cpuif_addr == 5'hc);
        decoded_reg_strb.g1_r2 = cpuif_req_masked & (cpuif_addr == 5'hd);
        decoded_reg_strb.g2_r1[0] = cpuif_req_masked & (cpuif_addr == 5'h10);
        decoded_reg_strb.g2_r1[1] = cpuif_req_masked & (cpuif_addr == 5'h11);
        decoded_reg_strb.g2_r2[0] = cpuif_req_masked & (cpuif_addr == 5'h12);
        decoded_reg_strb.g2_r2[1] = cpuif_req_masked & (cpuif_addr == 5'h13);
        decoded_reg_strb.g3_r1 = cpuif_req_masked & (cpuif_addr == 5'h14);
        decoded_reg_strb.g3_r2 = cpuif_req_masked & (cpuif_addr == 5'h15);
        decoded_reg_strb.g4_trig = cpuif_req_masked & (cpuif_addr == 5'h16);
        decoded_reg_strb.g4_r1 = cpuif_req_masked & (cpuif_addr == 5'h17);
        decoded_reg_strb.g4_r2 = cpuif_req_masked & (cpuif_addr == 5'h18);
    end

    // Pass down signals to next stage
    assign decoded_req = cpuif_req_masked;
    assign decoded_req_is_wr = cpuif_req_is_wr;
    assign decoded_wr_data = cpuif_wr_data;
    assign decoded_wr_biten = cpuif_wr_biten;

    //--------------------------------------------------------------------------
    // Field logic
    //--------------------------------------------------------------------------
    typedef struct {
        struct {
            struct {
                logic [2:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f1;
            struct {
                logic [2:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f2;
            struct {
                logic [2:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f3;
            struct {
                logic [2:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f4;
            struct {
                logic [2:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f5;
            struct {
                logic [2:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f6;
            struct {
                logic [2:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f7;
            struct {
                logic [2:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f8;
            struct {
                logic [2:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f9;
            struct {
                logic [2:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } fa;
        } reg1;
        struct {
            struct {
                logic [2:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } fa;
            struct {
                logic [2:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f9;
            struct {
                logic [2:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f8;
            struct {
                logic [2:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f7;
            struct {
                logic [2:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f6;
            struct {
                logic [2:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f5;
            struct {
                logic [2:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f4;
            struct {
                logic [2:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f3;
            struct {
                logic [2:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f2;
            struct {
                logic [2:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f1;
        } reg1_msb0;
        struct {
            struct {
                logic [4:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f1;
            struct {
                logic [4:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f2;
            struct {
                logic [4:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f3;
            struct {
                logic [4:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f4;
        } reg2;
        struct {
            struct {
                logic [7:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f1;
        } g1_r1;
        struct {
            struct {
                logic [7:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f1;
        } g1_r2;
        struct {
            struct {
                logic [15:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f1;
        } g2_r1;
        struct {
            struct {
                logic [15:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f1;
        } g2_r2;
        struct {
            struct {
                logic next;
                logic load_next;
            } trig;
        } g4_trig;
        struct {
            struct {
                logic [7:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f1;
        } g4_r1;
        struct {
            struct {
                logic [7:0] next;
                logic load_next;
                logic incrthreshold;
                logic overflow;
            } f1;
        } g4_r2;
    } field_combo_t;
    field_combo_t field_combo;

    typedef struct {
        struct {
            struct {
                logic [2:0] value;
            } f1;
            struct {
                logic [2:0] value;
            } f2;
            struct {
                logic [2:0] value;
            } f3;
            struct {
                logic [2:0] value;
            } f4;
            struct {
                logic [2:0] value;
            } f5;
            struct {
                logic [2:0] value;
            } f6;
            struct {
                logic [2:0] value;
            } f7;
            struct {
                logic [2:0] value;
            } f8;
            struct {
                logic [2:0] value;
            } f9;
            struct {
                logic [2:0] value;
            } fa;
        } reg1;
        struct {
            struct {
                logic [2:0] value;
            } fa;
            struct {
                logic [2:0] value;
            } f9;
            struct {
                logic [2:0] value;
            } f8;
            struct {
                logic [2:0] value;
            } f7;
            struct {
                logic [2:0] value;
            } f6;
            struct {
                logic [2:0] value;
            } f5;
            struct {
                logic [2:0] value;
            } f4;
            struct {
                logic [2:0] value;
            } f3;
            struct {
                logic [2:0] value;
            } f2;
            struct {
                logic [2:0] value;
            } f1;
        } reg1_msb0;
        struct {
            struct {
                logic [4:0] value;
            } f1;
            struct {
                logic [4:0] value;
            } f2;
            struct {
                logic [4:0] value;
            } f3;
            struct {
                logic [4:0] value;
            } f4;
        } reg2;
        struct {
            struct {
                logic [7:0] value;
            } f1;
        } g1_r1;
        struct {
            struct {
                logic [7:0] value;
            } f1;
        } g1_r2;
        struct {
            struct {
                logic [15:0] value;
            } f1;
        } g2_r1;
        struct {
            struct {
                logic [15:0] value;
            } f1;
        } g2_r2;
        struct {
            struct {
                logic value;
            } trig;
        } g4_trig;
        struct {
            struct {
                logic [7:0] value;
            } f1;
        } g4_r1;
        struct {
            struct {
                logic [7:0] value;
            } f1;
        } g4_r2;
    } field_storage_t;
    field_storage_t field_storage;

    // Field: regblock.reg1.f1
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.reg1.f1.value;
        load_next_c = '0;

        if(hwif_in.incr_en) begin // increment
            field_combo.reg1.f1.overflow = (((4)'(next_c) + 3'h1) > 3'h7);
            next_c = next_c + 3'h1;
            load_next_c = '1;
        end else begin
            field_combo.reg1.f1.overflow = '0;
        end
        field_combo.reg1.f1.incrthreshold = (field_storage.reg1.f1.value >= 3'h7);
        field_combo.reg1.f1.next = next_c;
        field_combo.reg1.f1.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.reg1.f1.value <= 3'h0;
        end else begin
            if(field_combo.reg1.f1.load_next) begin
                field_storage.reg1.f1.value <= field_combo.reg1.f1.next;
            end
        end
    end
    assign hwif_out.reg1.f1.value = field_storage.reg1.f1.value;
    // Field: regblock.reg1.f2
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.reg1.f2.value;
        load_next_c = '0;

        if(hwif_in.incr_en) begin // increment
            field_combo.reg1.f2.overflow = (((4)'(next_c) + 3'h1) > 3'h7);
            next_c = next_c + 3'h1;
            load_next_c = '1;
        end else begin
            field_combo.reg1.f2.overflow = '0;
        end
        field_combo.reg1.f2.incrthreshold = (field_storage.reg1.f2.value >= 3'h7);
        field_combo.reg1.f2.next = next_c;
        field_combo.reg1.f2.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.reg1.f2.value <= 3'h0;
        end else begin
            if(field_combo.reg1.f2.load_next) begin
                field_storage.reg1.f2.value <= field_combo.reg1.f2.next;
            end
        end
    end
    assign hwif_out.reg1.f2.value = field_storage.reg1.f2.value;
    // Field: regblock.reg1.f3
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.reg1.f3.value;
        load_next_c = '0;

        if(hwif_in.incr_en) begin // increment
            field_combo.reg1.f3.overflow = (((4)'(next_c) + 3'h1) > 3'h7);
            next_c = next_c + 3'h1;
            load_next_c = '1;
        end else begin
            field_combo.reg1.f3.overflow = '0;
        end
        field_combo.reg1.f3.incrthreshold = (field_storage.reg1.f3.value >= 3'h7);
        field_combo.reg1.f3.next = next_c;
        field_combo.reg1.f3.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.reg1.f3.value <= 3'h0;
        end else begin
            if(field_combo.reg1.f3.load_next) begin
                field_storage.reg1.f3.value <= field_combo.reg1.f3.next;
            end
        end
    end
    assign hwif_out.reg1.f3.value = field_storage.reg1.f3.value;
    // Field: regblock.reg1.f4
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.reg1.f4.value;
        load_next_c = '0;

        if(hwif_in.incr_en) begin // increment
            field_combo.reg1.f4.overflow = (((4)'(next_c) + 3'h1) > 3'h7);
            next_c = next_c + 3'h1;
            load_next_c = '1;
        end else begin
            field_combo.reg1.f4.overflow = '0;
        end
        field_combo.reg1.f4.incrthreshold = (field_storage.reg1.f4.value >= 3'h7);
        field_combo.reg1.f4.next = next_c;
        field_combo.reg1.f4.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.reg1.f4.value <= 3'h0;
        end else begin
            if(field_combo.reg1.f4.load_next) begin
                field_storage.reg1.f4.value <= field_combo.reg1.f4.next;
            end
        end
    end
    assign hwif_out.reg1.f4.value = field_storage.reg1.f4.value;
    // Field: regblock.reg1.f5
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.reg1.f5.value;
        load_next_c = '0;

        if(hwif_in.incr_en) begin // increment
            field_combo.reg1.f5.overflow = (((4)'(next_c) + 3'h1) > 3'h7);
            next_c = next_c + 3'h1;
            load_next_c = '1;
        end else begin
            field_combo.reg1.f5.overflow = '0;
        end
        field_combo.reg1.f5.incrthreshold = (field_storage.reg1.f5.value >= 3'h7);
        field_combo.reg1.f5.next = next_c;
        field_combo.reg1.f5.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.reg1.f5.value <= 3'h0;
        end else begin
            if(field_combo.reg1.f5.load_next) begin
                field_storage.reg1.f5.value <= field_combo.reg1.f5.next;
            end
        end
    end
    assign hwif_out.reg1.f5.value = field_storage.reg1.f5.value;
    // Field: regblock.reg1.f6
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.reg1.f6.value;
        load_next_c = '0;

        if(hwif_in.incr_en) begin // increment
            field_combo.reg1.f6.overflow = (((4)'(next_c) + 3'h1) > 3'h7);
            next_c = next_c + 3'h1;
            load_next_c = '1;
        end else begin
            field_combo.reg1.f6.overflow = '0;
        end
        field_combo.reg1.f6.incrthreshold = (field_storage.reg1.f6.value >= 3'h7);
        field_combo.reg1.f6.next = next_c;
        field_combo.reg1.f6.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.reg1.f6.value <= 3'h0;
        end else begin
            if(field_combo.reg1.f6.load_next) begin
                field_storage.reg1.f6.value <= field_combo.reg1.f6.next;
            end
        end
    end
    assign hwif_out.reg1.f6.value = field_storage.reg1.f6.value;
    // Field: regblock.reg1.f7
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.reg1.f7.value;
        load_next_c = '0;

        if(hwif_in.incr_en) begin // increment
            field_combo.reg1.f7.overflow = (((4)'(next_c) + 3'h1) > 3'h7);
            next_c = next_c + 3'h1;
            load_next_c = '1;
        end else begin
            field_combo.reg1.f7.overflow = '0;
        end
        field_combo.reg1.f7.incrthreshold = (field_storage.reg1.f7.value >= 3'h7);
        field_combo.reg1.f7.next = next_c;
        field_combo.reg1.f7.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.reg1.f7.value <= 3'h0;
        end else begin
            if(field_combo.reg1.f7.load_next) begin
                field_storage.reg1.f7.value <= field_combo.reg1.f7.next;
            end
        end
    end
    assign hwif_out.reg1.f7.value = field_storage.reg1.f7.value;
    // Field: regblock.reg1.f8
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.reg1.f8.value;
        load_next_c = '0;

        if(hwif_in.incr_en) begin // increment
            field_combo.reg1.f8.overflow = (((4)'(next_c) + 3'h1) > 3'h7);
            next_c = next_c + 3'h1;
            load_next_c = '1;
        end else begin
            field_combo.reg1.f8.overflow = '0;
        end
        field_combo.reg1.f8.incrthreshold = (field_storage.reg1.f8.value >= 3'h7);
        field_combo.reg1.f8.next = next_c;
        field_combo.reg1.f8.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.reg1.f8.value <= 3'h0;
        end else begin
            if(field_combo.reg1.f8.load_next) begin
                field_storage.reg1.f8.value <= field_combo.reg1.f8.next;
            end
        end
    end
    assign hwif_out.reg1.f8.value = field_storage.reg1.f8.value;
    // Field: regblock.reg1.f9
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.reg1.f9.value;
        load_next_c = '0;

        if(hwif_in.incr_en) begin // increment
            field_combo.reg1.f9.overflow = (((4)'(next_c) + 3'h1) > 3'h7);
            next_c = next_c + 3'h1;
            load_next_c = '1;
        end else begin
            field_combo.reg1.f9.overflow = '0;
        end
        field_combo.reg1.f9.incrthreshold = (field_storage.reg1.f9.value >= 3'h7);
        field_combo.reg1.f9.next = next_c;
        field_combo.reg1.f9.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.reg1.f9.value <= 3'h0;
        end else begin
            if(field_combo.reg1.f9.load_next) begin
                field_storage.reg1.f9.value <= field_combo.reg1.f9.next;
            end
        end
    end
    assign hwif_out.reg1.f9.value = field_storage.reg1.f9.value;
    // Field: regblock.reg1.fa
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.reg1.fa.value;
        load_next_c = '0;

        if(hwif_in.incr_en) begin // increment
            field_combo.reg1.fa.overflow = (((4)'(next_c) + 3'h1) > 3'h7);
            next_c = next_c + 3'h1;
            load_next_c = '1;
        end else begin
            field_combo.reg1.fa.overflow = '0;
        end
        field_combo.reg1.fa.incrthreshold = (field_storage.reg1.fa.value >= 3'h7);
        field_combo.reg1.fa.next = next_c;
        field_combo.reg1.fa.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.reg1.fa.value <= 3'h0;
        end else begin
            if(field_combo.reg1.fa.load_next) begin
                field_storage.reg1.fa.value <= field_combo.reg1.fa.next;
            end
        end
    end
    assign hwif_out.reg1.fa.value = field_storage.reg1.fa.value;
    // Field: regblock.reg1_msb0.fa
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.reg1_msb0.fa.value;
        load_next_c = '0;

        if(hwif_in.incr_en) begin // increment
            field_combo.reg1_msb0.fa.overflow = (((4)'(next_c) + 3'h1) > 3'h7);
            next_c = next_c + 3'h1;
            load_next_c = '1;
        end else begin
            field_combo.reg1_msb0.fa.overflow = '0;
        end
        field_combo.reg1_msb0.fa.incrthreshold = (field_storage.reg1_msb0.fa.value >= 3'h7);
        field_combo.reg1_msb0.fa.next = next_c;
        field_combo.reg1_msb0.fa.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.reg1_msb0.fa.value <= 3'h0;
        end else begin
            if(field_combo.reg1_msb0.fa.load_next) begin
                field_storage.reg1_msb0.fa.value <= field_combo.reg1_msb0.fa.next;
            end
        end
    end
    assign hwif_out.reg1_msb0.fa.value = field_storage.reg1_msb0.fa.value;
    // Field: regblock.reg1_msb0.f9
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.reg1_msb0.f9.value;
        load_next_c = '0;

        if(hwif_in.incr_en) begin // increment
            field_combo.reg1_msb0.f9.overflow = (((4)'(next_c) + 3'h1) > 3'h7);
            next_c = next_c + 3'h1;
            load_next_c = '1;
        end else begin
            field_combo.reg1_msb0.f9.overflow = '0;
        end
        field_combo.reg1_msb0.f9.incrthreshold = (field_storage.reg1_msb0.f9.value >= 3'h7);
        field_combo.reg1_msb0.f9.next = next_c;
        field_combo.reg1_msb0.f9.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.reg1_msb0.f9.value <= 3'h0;
        end else begin
            if(field_combo.reg1_msb0.f9.load_next) begin
                field_storage.reg1_msb0.f9.value <= field_combo.reg1_msb0.f9.next;
            end
        end
    end
    assign hwif_out.reg1_msb0.f9.value = field_storage.reg1_msb0.f9.value;
    // Field: regblock.reg1_msb0.f8
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.reg1_msb0.f8.value;
        load_next_c = '0;

        if(hwif_in.incr_en) begin // increment
            field_combo.reg1_msb0.f8.overflow = (((4)'(next_c) + 3'h1) > 3'h7);
            next_c = next_c + 3'h1;
            load_next_c = '1;
        end else begin
            field_combo.reg1_msb0.f8.overflow = '0;
        end
        field_combo.reg1_msb0.f8.incrthreshold = (field_storage.reg1_msb0.f8.value >= 3'h7);
        field_combo.reg1_msb0.f8.next = next_c;
        field_combo.reg1_msb0.f8.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.reg1_msb0.f8.value <= 3'h0;
        end else begin
            if(field_combo.reg1_msb0.f8.load_next) begin
                field_storage.reg1_msb0.f8.value <= field_combo.reg1_msb0.f8.next;
            end
        end
    end
    assign hwif_out.reg1_msb0.f8.value = field_storage.reg1_msb0.f8.value;
    // Field: regblock.reg1_msb0.f7
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.reg1_msb0.f7.value;
        load_next_c = '0;

        if(hwif_in.incr_en) begin // increment
            field_combo.reg1_msb0.f7.overflow = (((4)'(next_c) + 3'h1) > 3'h7);
            next_c = next_c + 3'h1;
            load_next_c = '1;
        end else begin
            field_combo.reg1_msb0.f7.overflow = '0;
        end
        field_combo.reg1_msb0.f7.incrthreshold = (field_storage.reg1_msb0.f7.value >= 3'h7);
        field_combo.reg1_msb0.f7.next = next_c;
        field_combo.reg1_msb0.f7.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.reg1_msb0.f7.value <= 3'h0;
        end else begin
            if(field_combo.reg1_msb0.f7.load_next) begin
                field_storage.reg1_msb0.f7.value <= field_combo.reg1_msb0.f7.next;
            end
        end
    end
    assign hwif_out.reg1_msb0.f7.value = field_storage.reg1_msb0.f7.value;
    // Field: regblock.reg1_msb0.f6
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.reg1_msb0.f6.value;
        load_next_c = '0;

        if(hwif_in.incr_en) begin // increment
            field_combo.reg1_msb0.f6.overflow = (((4)'(next_c) + 3'h1) > 3'h7);
            next_c = next_c + 3'h1;
            load_next_c = '1;
        end else begin
            field_combo.reg1_msb0.f6.overflow = '0;
        end
        field_combo.reg1_msb0.f6.incrthreshold = (field_storage.reg1_msb0.f6.value >= 3'h7);
        field_combo.reg1_msb0.f6.next = next_c;
        field_combo.reg1_msb0.f6.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.reg1_msb0.f6.value <= 3'h0;
        end else begin
            if(field_combo.reg1_msb0.f6.load_next) begin
                field_storage.reg1_msb0.f6.value <= field_combo.reg1_msb0.f6.next;
            end
        end
    end
    assign hwif_out.reg1_msb0.f6.value = field_storage.reg1_msb0.f6.value;
    // Field: regblock.reg1_msb0.f5
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.reg1_msb0.f5.value;
        load_next_c = '0;

        if(hwif_in.incr_en) begin // increment
            field_combo.reg1_msb0.f5.overflow = (((4)'(next_c) + 3'h1) > 3'h7);
            next_c = next_c + 3'h1;
            load_next_c = '1;
        end else begin
            field_combo.reg1_msb0.f5.overflow = '0;
        end
        field_combo.reg1_msb0.f5.incrthreshold = (field_storage.reg1_msb0.f5.value >= 3'h7);
        field_combo.reg1_msb0.f5.next = next_c;
        field_combo.reg1_msb0.f5.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.reg1_msb0.f5.value <= 3'h0;
        end else begin
            if(field_combo.reg1_msb0.f5.load_next) begin
                field_storage.reg1_msb0.f5.value <= field_combo.reg1_msb0.f5.next;
            end
        end
    end
    assign hwif_out.reg1_msb0.f5.value = field_storage.reg1_msb0.f5.value;
    // Field: regblock.reg1_msb0.f4
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.reg1_msb0.f4.value;
        load_next_c = '0;

        if(hwif_in.incr_en) begin // increment
            field_combo.reg1_msb0.f4.overflow = (((4)'(next_c) + 3'h1) > 3'h7);
            next_c = next_c + 3'h1;
            load_next_c = '1;
        end else begin
            field_combo.reg1_msb0.f4.overflow = '0;
        end
        field_combo.reg1_msb0.f4.incrthreshold = (field_storage.reg1_msb0.f4.value >= 3'h7);
        field_combo.reg1_msb0.f4.next = next_c;
        field_combo.reg1_msb0.f4.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.reg1_msb0.f4.value <= 3'h0;
        end else begin
            if(field_combo.reg1_msb0.f4.load_next) begin
                field_storage.reg1_msb0.f4.value <= field_combo.reg1_msb0.f4.next;
            end
        end
    end
    assign hwif_out.reg1_msb0.f4.value = field_storage.reg1_msb0.f4.value;
    // Field: regblock.reg1_msb0.f3
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.reg1_msb0.f3.value;
        load_next_c = '0;

        if(hwif_in.incr_en) begin // increment
            field_combo.reg1_msb0.f3.overflow = (((4)'(next_c) + 3'h1) > 3'h7);
            next_c = next_c + 3'h1;
            load_next_c = '1;
        end else begin
            field_combo.reg1_msb0.f3.overflow = '0;
        end
        field_combo.reg1_msb0.f3.incrthreshold = (field_storage.reg1_msb0.f3.value >= 3'h7);
        field_combo.reg1_msb0.f3.next = next_c;
        field_combo.reg1_msb0.f3.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.reg1_msb0.f3.value <= 3'h0;
        end else begin
            if(field_combo.reg1_msb0.f3.load_next) begin
                field_storage.reg1_msb0.f3.value <= field_combo.reg1_msb0.f3.next;
            end
        end
    end
    assign hwif_out.reg1_msb0.f3.value = field_storage.reg1_msb0.f3.value;
    // Field: regblock.reg1_msb0.f2
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.reg1_msb0.f2.value;
        load_next_c = '0;

        if(hwif_in.incr_en) begin // increment
            field_combo.reg1_msb0.f2.overflow = (((4)'(next_c) + 3'h1) > 3'h7);
            next_c = next_c + 3'h1;
            load_next_c = '1;
        end else begin
            field_combo.reg1_msb0.f2.overflow = '0;
        end
        field_combo.reg1_msb0.f2.incrthreshold = (field_storage.reg1_msb0.f2.value >= 3'h7);
        field_combo.reg1_msb0.f2.next = next_c;
        field_combo.reg1_msb0.f2.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.reg1_msb0.f2.value <= 3'h0;
        end else begin
            if(field_combo.reg1_msb0.f2.load_next) begin
                field_storage.reg1_msb0.f2.value <= field_combo.reg1_msb0.f2.next;
            end
        end
    end
    assign hwif_out.reg1_msb0.f2.value = field_storage.reg1_msb0.f2.value;
    // Field: regblock.reg1_msb0.f1
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.reg1_msb0.f1.value;
        load_next_c = '0;

        if(hwif_in.incr_en) begin // increment
            field_combo.reg1_msb0.f1.overflow = (((4)'(next_c) + 3'h1) > 3'h7);
            next_c = next_c + 3'h1;
            load_next_c = '1;
        end else begin
            field_combo.reg1_msb0.f1.overflow = '0;
        end
        field_combo.reg1_msb0.f1.incrthreshold = (field_storage.reg1_msb0.f1.value >= 3'h7);
        field_combo.reg1_msb0.f1.next = next_c;
        field_combo.reg1_msb0.f1.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.reg1_msb0.f1.value <= 3'h0;
        end else begin
            if(field_combo.reg1_msb0.f1.load_next) begin
                field_storage.reg1_msb0.f1.value <= field_combo.reg1_msb0.f1.next;
            end
        end
    end
    assign hwif_out.reg1_msb0.f1.value = field_storage.reg1_msb0.f1.value;
    // Field: regblock.reg2.f1
    always_comb begin
        automatic logic [4:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.reg2.f1.value;
        load_next_c = '0;
        if(decoded_reg_strb.reg2[0] && !decoded_req_is_wr) begin // SW clear on read
            next_c = '0;
            load_next_c = '1;
        end
        if(hwif_in.incr_en) begin // increment
            field_combo.reg2.f1.overflow = (((6)'(next_c) + 5'h1) > 5'h1f);
            next_c = next_c + 5'h1;
            load_next_c = '1;
        end else begin
            field_combo.reg2.f1.overflow = '0;
        end
        field_combo.reg2.f1.incrthreshold = (field_storage.reg2.f1.value >= 5'h1f);
        field_combo.reg2.f1.next = next_c;
        field_combo.reg2.f1.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.reg2.f1.value <= 5'h0;
        end else begin
            if(field_combo.reg2.f1.load_next) begin
                field_storage.reg2.f1.value <= field_combo.reg2.f1.next;
            end
        end
    end
    assign hwif_out.reg2.f1.value = field_storage.reg2.f1.value;
    // Field: regblock.reg2.f2
    always_comb begin
        automatic logic [4:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.reg2.f2.value;
        load_next_c = '0;
        if(decoded_reg_strb.reg2[0] && !decoded_req_is_wr) begin // SW clear on read
            next_c = '0;
            load_next_c = '1;
        end
        if(hwif_in.incr_en) begin // increment
            field_combo.reg2.f2.overflow = (((6)'(next_c) + 5'h1) > 5'h1f);
            next_c = next_c + 5'h1;
            load_next_c = '1;
        end else begin
            field_combo.reg2.f2.overflow = '0;
        end
        field_combo.reg2.f2.incrthreshold = (field_storage.reg2.f2.value >= 5'h1f);
        field_combo.reg2.f2.next = next_c;
        field_combo.reg2.f2.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.reg2.f2.value <= 5'h0;
        end else begin
            if(field_combo.reg2.f2.load_next) begin
                field_storage.reg2.f2.value <= field_combo.reg2.f2.next;
            end
        end
    end
    assign hwif_out.reg2.f2.value = field_storage.reg2.f2.value;
    // Field: regblock.reg2.f3
    always_comb begin
        automatic logic [4:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.reg2.f3.value;
        load_next_c = '0;
        if(decoded_reg_strb.reg2[0] && !decoded_req_is_wr) begin // SW clear on read
            next_c = '0;
            load_next_c = '1;
        end
        if(hwif_in.incr_en) begin // increment
            field_combo.reg2.f3.overflow = (((6)'(next_c) + 5'h1) > 5'h1f);
            next_c = next_c + 5'h1;
            load_next_c = '1;
        end else begin
            field_combo.reg2.f3.overflow = '0;
        end
        field_combo.reg2.f3.incrthreshold = (field_storage.reg2.f3.value >= 5'h1f);
        field_combo.reg2.f3.next = next_c;
        field_combo.reg2.f3.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.reg2.f3.value <= 5'h0;
        end else begin
            if(field_combo.reg2.f3.load_next) begin
                field_storage.reg2.f3.value <= field_combo.reg2.f3.next;
            end
        end
    end
    assign hwif_out.reg2.f3.value = field_storage.reg2.f3.value;
    // Field: regblock.reg2.f4
    always_comb begin
        automatic logic [4:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.reg2.f4.value;
        load_next_c = '0;
        if(decoded_reg_strb.reg2[0] && !decoded_req_is_wr) begin // SW clear on read
            next_c = '0;
            load_next_c = '1;
        end
        if(hwif_in.incr_en) begin // increment
            field_combo.reg2.f4.overflow = (((6)'(next_c) + 5'h1) > 5'h1f);
            next_c = next_c + 5'h1;
            load_next_c = '1;
        end else begin
            field_combo.reg2.f4.overflow = '0;
        end
        field_combo.reg2.f4.incrthreshold = (field_storage.reg2.f4.value >= 5'h1f);
        field_combo.reg2.f4.next = next_c;
        field_combo.reg2.f4.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.reg2.f4.value <= 5'h0;
        end else begin
            if(field_combo.reg2.f4.load_next) begin
                field_storage.reg2.f4.value <= field_combo.reg2.f4.next;
            end
        end
    end
    assign hwif_out.reg2.f4.value = field_storage.reg2.f4.value;
    // Field: regblock.g1_r1.f1
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.g1_r1.f1.value;
        load_next_c = '0;

        if(hwif_in.incr_en) begin // increment
            field_combo.g1_r1.f1.overflow = (((9)'(next_c) + 8'h1) > 8'hff);
            next_c = next_c + 8'h1;
            load_next_c = '1;
        end else begin
            field_combo.g1_r1.f1.overflow = '0;
        end
        field_combo.g1_r1.f1.incrthreshold = (field_storage.g1_r1.f1.value >= 8'hff);
        field_combo.g1_r1.f1.next = next_c;
        field_combo.g1_r1.f1.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.g1_r1.f1.value <= 8'h0;
        end else begin
            if(field_combo.g1_r1.f1.load_next) begin
                field_storage.g1_r1.f1.value <= field_combo.g1_r1.f1.next;
            end
        end
    end
    assign hwif_out.g1_r1.f1.value = field_storage.g1_r1.f1.value;
    // Field: regblock.g1_r2.f1
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.g1_r2.f1.value;
        load_next_c = '0;

        if(hwif_in.incr_en) begin // increment
            field_combo.g1_r2.f1.overflow = (((9)'(next_c) + 8'h1) > 8'hff);
            next_c = next_c + 8'h1;
            load_next_c = '1;
        end else begin
            field_combo.g1_r2.f1.overflow = '0;
        end
        field_combo.g1_r2.f1.incrthreshold = (field_storage.g1_r2.f1.value >= 8'hff);
        field_combo.g1_r2.f1.next = next_c;
        field_combo.g1_r2.f1.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.g1_r2.f1.value <= 8'h0;
        end else begin
            if(field_combo.g1_r2.f1.load_next) begin
                field_storage.g1_r2.f1.value <= field_combo.g1_r2.f1.next;
            end
        end
    end
    assign hwif_out.g1_r2.f1.value = field_storage.g1_r2.f1.value;
    // Field: regblock.g2_r1.f1
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.g2_r1.f1.value;
        load_next_c = '0;

        if(hwif_in.incr_en) begin // increment
            field_combo.g2_r1.f1.overflow = (((17)'(next_c) + 16'h1) > 16'hffff);
            next_c = next_c + 16'h1;
            load_next_c = '1;
        end else begin
            field_combo.g2_r1.f1.overflow = '0;
        end
        field_combo.g2_r1.f1.incrthreshold = (field_storage.g2_r1.f1.value >= 16'hffff);
        field_combo.g2_r1.f1.next = next_c;
        field_combo.g2_r1.f1.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.g2_r1.f1.value <= 16'haaaa;
        end else begin
            if(field_combo.g2_r1.f1.load_next) begin
                field_storage.g2_r1.f1.value <= field_combo.g2_r1.f1.next;
            end
        end
    end
    assign hwif_out.g2_r1.f1.value = field_storage.g2_r1.f1.value;
    // Field: regblock.g2_r2.f1
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.g2_r2.f1.value;
        load_next_c = '0;

        if(hwif_in.incr_en) begin // increment
            field_combo.g2_r2.f1.overflow = (((17)'(next_c) + 16'h1) > 16'hffff);
            next_c = next_c + 16'h1;
            load_next_c = '1;
        end else begin
            field_combo.g2_r2.f1.overflow = '0;
        end
        field_combo.g2_r2.f1.incrthreshold = (field_storage.g2_r2.f1.value >= 16'hffff);
        field_combo.g2_r2.f1.next = next_c;
        field_combo.g2_r2.f1.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.g2_r2.f1.value <= 16'haaaa;
        end else begin
            if(field_combo.g2_r2.f1.load_next) begin
                field_storage.g2_r2.f1.value <= field_combo.g2_r2.f1.next;
            end
        end
    end
    assign hwif_out.g2_r2.f1.value = field_storage.g2_r2.f1.value;
    // Field: regblock.g4_trig.trig
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.g4_trig.trig.value;
        load_next_c = '0;
        if(decoded_reg_strb.g4_trig && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.g4_trig.trig.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end else begin // singlepulse clears back to 0
            next_c = '0;
            load_next_c = '1;
        end
        field_combo.g4_trig.trig.next = next_c;
        field_combo.g4_trig.trig.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.g4_trig.trig.value <= 1'h0;
        end else begin
            if(field_combo.g4_trig.trig.load_next) begin
                field_storage.g4_trig.trig.value <= field_combo.g4_trig.trig.next;
            end
        end
    end
    assign hwif_out.g4_trig.trig.value = field_storage.g4_trig.trig.value;
    // Field: regblock.g4_r1.f1
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.g4_r1.f1.value;
        load_next_c = '0;

        if(hwif_in.incr_en) begin // increment
            field_combo.g4_r1.f1.overflow = (((9)'(next_c) + 8'h1) > 8'hff);
            next_c = next_c + 8'h1;
            load_next_c = '1;
        end else begin
            field_combo.g4_r1.f1.overflow = '0;
        end
        field_combo.g4_r1.f1.incrthreshold = (field_storage.g4_r1.f1.value >= 8'hff);
        field_combo.g4_r1.f1.next = next_c;
        field_combo.g4_r1.f1.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.g4_r1.f1.value <= 8'h0;
        end else begin
            if(field_combo.g4_r1.f1.load_next) begin
                field_storage.g4_r1.f1.value <= field_combo.g4_r1.f1.next;
            end
        end
    end
    assign hwif_out.g4_r1.f1.value = field_storage.g4_r1.f1.value;
    // Field: regblock.g4_r2.f1
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.g4_r2.f1.value;
        load_next_c = '0;

        if(hwif_in.incr_en) begin // increment
            field_combo.g4_r2.f1.overflow = (((9)'(next_c) + 8'h1) > 8'hff);
            next_c = next_c + 8'h1;
            load_next_c = '1;
        end else begin
            field_combo.g4_r2.f1.overflow = '0;
        end
        field_combo.g4_r2.f1.incrthreshold = (field_storage.g4_r2.f1.value >= 8'hff);
        field_combo.g4_r2.f1.next = next_c;
        field_combo.g4_r2.f1.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.g4_r2.f1.value <= 8'h0;
        end else begin
            if(field_combo.g4_r2.f1.load_next) begin
                field_storage.g4_r2.f1.value <= field_combo.g4_r2.f1.next;
            end
        end
    end
    assign hwif_out.g4_r2.f1.value = field_storage.g4_r2.f1.value;

    //--------------------------------------------------------------------------
    // Read double-buffers
    //--------------------------------------------------------------------------
    typedef struct {
        struct {
            logic [31:0] data;
        } reg1;
        struct {
            logic [31:0] data;
        } reg1_msb0;
        struct {
            logic [31:0] data;
        } reg2;
        struct {
            logic [7:0] data;
        } g1_r1;
        struct {
            logic [7:0] data;
        } g1_r2;
        struct {
            logic [15:0] data;
        } g2_r1;
        struct {
            logic [15:0] data;
        } g2_r2;
        struct {
            logic [7:0] data;
        } g3_r1;
        struct {
            logic [7:0] data;
        } g3_r2;
        struct {
            logic [7:0] data;
        } g4_r1;
        struct {
            logic [7:0] data;
        } g4_r2;
    } rbuf_storage_t;
    rbuf_storage_t rbuf_storage;

    always_ff @(posedge clk) begin
        if(decoded_reg_strb.reg1[0] && !decoded_req_is_wr) begin
            rbuf_storage.reg1.data[2:0] <= field_storage.reg1.f1.value;
            rbuf_storage.reg1.data[5:3] <= field_storage.reg1.f2.value;
            rbuf_storage.reg1.data[8:6] <= field_storage.reg1.f3.value;
            rbuf_storage.reg1.data[11:9] <= field_storage.reg1.f4.value;
            rbuf_storage.reg1.data[14:12] <= field_storage.reg1.f5.value;
            rbuf_storage.reg1.data[17:15] <= field_storage.reg1.f6.value;
            rbuf_storage.reg1.data[20:18] <= field_storage.reg1.f7.value;
            rbuf_storage.reg1.data[23:21] <= field_storage.reg1.f8.value;
            rbuf_storage.reg1.data[26:24] <= field_storage.reg1.f9.value;
            rbuf_storage.reg1.data[29:27] <= field_storage.reg1.fa.value;
            rbuf_storage.reg1.data[31:30] <= '0;
        end
    end
    always_ff @(posedge clk) begin
        if(decoded_reg_strb.reg1_msb0[0] && !decoded_req_is_wr) begin
            rbuf_storage.reg1_msb0.data[0:0] <= '0;
            rbuf_storage.reg1_msb0.data[3:1] <= {<<{field_storage.reg1_msb0.fa.value}};
            rbuf_storage.reg1_msb0.data[6:4] <= {<<{field_storage.reg1_msb0.f9.value}};
            rbuf_storage.reg1_msb0.data[9:7] <= {<<{field_storage.reg1_msb0.f8.value}};
            rbuf_storage.reg1_msb0.data[12:10] <= {<<{field_storage.reg1_msb0.f7.value}};
            rbuf_storage.reg1_msb0.data[15:13] <= {<<{field_storage.reg1_msb0.f6.value}};
            rbuf_storage.reg1_msb0.data[18:16] <= {<<{field_storage.reg1_msb0.f5.value}};
            rbuf_storage.reg1_msb0.data[21:19] <= {<<{field_storage.reg1_msb0.f4.value}};
            rbuf_storage.reg1_msb0.data[24:22] <= {<<{field_storage.reg1_msb0.f3.value}};
            rbuf_storage.reg1_msb0.data[27:25] <= {<<{field_storage.reg1_msb0.f2.value}};
            rbuf_storage.reg1_msb0.data[30:28] <= {<<{field_storage.reg1_msb0.f1.value}};
            rbuf_storage.reg1_msb0.data[31:31] <= '0;
        end
    end
    always_ff @(posedge clk) begin
        if(decoded_reg_strb.reg2[0] && !decoded_req_is_wr) begin
            rbuf_storage.reg2.data[4:0] <= field_storage.reg2.f1.value;
            rbuf_storage.reg2.data[9:5] <= '0;
            rbuf_storage.reg2.data[14:10] <= field_storage.reg2.f2.value;
            rbuf_storage.reg2.data[21:15] <= '0;
            rbuf_storage.reg2.data[26:22] <= field_storage.reg2.f3.value;
            rbuf_storage.reg2.data[31:27] <= field_storage.reg2.f4.value;
        end
    end
    always_ff @(posedge clk) begin
        if(decoded_reg_strb.g1_r1 && !decoded_req_is_wr) begin
            rbuf_storage.g1_r1.data[7:0] <= field_storage.g1_r1.f1.value;
        end
    end
    always_ff @(posedge clk) begin
        if(decoded_reg_strb.g1_r1 && !decoded_req_is_wr) begin
            rbuf_storage.g1_r2.data[7:0] <= field_storage.g1_r2.f1.value;
        end
    end
    always_ff @(posedge clk) begin
        if(decoded_reg_strb.g2_r1[0] && !decoded_req_is_wr) begin
            rbuf_storage.g2_r1.data[15:0] <= field_storage.g2_r1.f1.value;
        end
    end
    always_ff @(posedge clk) begin
        if(decoded_reg_strb.g2_r1[0] && !decoded_req_is_wr) begin
            rbuf_storage.g2_r2.data[15:0] <= field_storage.g2_r2.f1.value;
        end
    end
    always_ff @(posedge clk) begin
        if(hwif_in.trigger_sig) begin
            rbuf_storage.g3_r1.data[7:0] <= hwif_in.g3_r1.f1.next;
        end
    end
    always_ff @(posedge clk) begin
        if(~hwif_in.trigger_sig_n) begin
            rbuf_storage.g3_r2.data[7:0] <= hwif_in.g3_r2.f1.next;
        end
    end
    always_ff @(posedge clk) begin
        if(field_storage.g4_trig.trig.value) begin
            rbuf_storage.g4_r1.data[7:0] <= field_storage.g4_r1.f1.value;
        end
    end
    always_ff @(posedge clk) begin
        if(decoded_reg_strb.g4_trig && decoded_req_is_wr && |(decoded_wr_biten[0:0])) begin
            rbuf_storage.g4_r2.data[7:0] <= field_storage.g4_r2.f1.value;
        end
    end

    //--------------------------------------------------------------------------
    // Write response
    //--------------------------------------------------------------------------
    assign cpuif_wr_ack = decoded_req & decoded_req_is_wr;
    // Writes are always granted with no error response
    assign cpuif_wr_err = '0;

    //--------------------------------------------------------------------------
    // Readback
    //--------------------------------------------------------------------------

    logic readback_err;
    logic readback_done;
    logic [7:0] readback_data;

    // Assign readback values to a flattened array
    logic [7:0] readback_array[22];
    assign readback_array[0][2:0] = (decoded_reg_strb.reg1[0] && !decoded_req_is_wr) ? field_storage.reg1.f1.value : '0;
    assign readback_array[0][5:3] = (decoded_reg_strb.reg1[0] && !decoded_req_is_wr) ? field_storage.reg1.f2.value : '0;
    assign readback_array[0][7:6] = (decoded_reg_strb.reg1[0] && !decoded_req_is_wr) ? field_storage.reg1.f3.value[1:0] : '0;
    assign readback_array[1] = (decoded_reg_strb.reg1[1] && !decoded_req_is_wr) ? rbuf_storage.reg1.data[15:8] : '0;
    assign readback_array[2] = (decoded_reg_strb.reg1[2] && !decoded_req_is_wr) ? rbuf_storage.reg1.data[23:16] : '0;
    assign readback_array[3] = (decoded_reg_strb.reg1[3] && !decoded_req_is_wr) ? rbuf_storage.reg1.data[31:24] : '0;
    assign readback_array[4][0:0] = '0;
    assign readback_array[4][3:1] = (decoded_reg_strb.reg1_msb0[0] && !decoded_req_is_wr) ? {<<{field_storage.reg1_msb0.fa.value}} : '0;
    assign readback_array[4][6:4] = (decoded_reg_strb.reg1_msb0[0] && !decoded_req_is_wr) ? {<<{field_storage.reg1_msb0.f9.value}} : '0;
    assign readback_array[4][7:7] = (decoded_reg_strb.reg1_msb0[0] && !decoded_req_is_wr) ? {<<{field_storage.reg1_msb0.f8.value[2]}} : '0;
    assign readback_array[5] = (decoded_reg_strb.reg1_msb0[1] && !decoded_req_is_wr) ? rbuf_storage.reg1_msb0.data[15:8] : '0;
    assign readback_array[6] = (decoded_reg_strb.reg1_msb0[2] && !decoded_req_is_wr) ? rbuf_storage.reg1_msb0.data[23:16] : '0;
    assign readback_array[7] = (decoded_reg_strb.reg1_msb0[3] && !decoded_req_is_wr) ? rbuf_storage.reg1_msb0.data[31:24] : '0;
    assign readback_array[8][4:0] = (decoded_reg_strb.reg2[0] && !decoded_req_is_wr) ? field_storage.reg2.f1.value : '0;
    assign readback_array[8][7:5] = '0;
    assign readback_array[9] = (decoded_reg_strb.reg2[1] && !decoded_req_is_wr) ? rbuf_storage.reg2.data[15:8] : '0;
    assign readback_array[10] = (decoded_reg_strb.reg2[2] && !decoded_req_is_wr) ? rbuf_storage.reg2.data[23:16] : '0;
    assign readback_array[11] = (decoded_reg_strb.reg2[3] && !decoded_req_is_wr) ? rbuf_storage.reg2.data[31:24] : '0;
    assign readback_array[12][7:0] = (decoded_reg_strb.g1_r1 && !decoded_req_is_wr) ? field_storage.g1_r1.f1.value : '0;
    assign readback_array[13][7:0] = (decoded_reg_strb.g1_r2 && !decoded_req_is_wr) ? rbuf_storage.g1_r2.data : '0;
    assign readback_array[14][7:0] = (decoded_reg_strb.g2_r1[0] && !decoded_req_is_wr) ? field_storage.g2_r1.f1.value[7:0] : '0;
    assign readback_array[15] = (decoded_reg_strb.g2_r1[1] && !decoded_req_is_wr) ? rbuf_storage.g2_r1.data[15:8] : '0;
    assign readback_array[16] = (decoded_reg_strb.g2_r2[0] && !decoded_req_is_wr) ? rbuf_storage.g2_r2.data[7:0] : '0;
    assign readback_array[17] = (decoded_reg_strb.g2_r2[1] && !decoded_req_is_wr) ? rbuf_storage.g2_r2.data[15:8] : '0;
    assign readback_array[18][7:0] = (decoded_reg_strb.g3_r1 && !decoded_req_is_wr) ? rbuf_storage.g3_r1.data : '0;
    assign readback_array[19][7:0] = (decoded_reg_strb.g3_r2 && !decoded_req_is_wr) ? rbuf_storage.g3_r2.data : '0;
    assign readback_array[20][7:0] = (decoded_reg_strb.g4_r1 && !decoded_req_is_wr) ? rbuf_storage.g4_r1.data : '0;
    assign readback_array[21][7:0] = (decoded_reg_strb.g4_r2 && !decoded_req_is_wr) ? rbuf_storage.g4_r2.data : '0;

    // Reduce the array
    always_comb begin
        automatic logic [7:0] readback_data_var;
        readback_done = decoded_req & ~decoded_req_is_wr;
        readback_err = '0;
        readback_data_var = '0;
        for(int i=0; i<22; i++) readback_data_var |= readback_array[i];
        readback_data = readback_data_var;
    end

    assign cpuif_rd_ack = readback_done;
    assign cpuif_rd_data = readback_data;
    assign cpuif_rd_err = readback_err;
endmodule
