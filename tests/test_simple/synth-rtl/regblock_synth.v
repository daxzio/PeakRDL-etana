/* Generated by Yosys 0.58 (git sha1 157aabb58, g++ 13.3.0-6ubuntu2~24.04 -fPIC -O3) */

module regblock(clk, rst, s_apb_psel, s_apb_pwrite, s_apb_penable, s_apb_pprot, s_apb_paddr, s_apb_pwdata, s_apb_pstrb, s_apb_pready, s_apb_prdata, s_apb_pslverr);
  input clk;
  wire clk;
  input rst;
  wire rst;
  input s_apb_psel;
  wire s_apb_psel;
  input s_apb_pwrite;
  wire s_apb_pwrite;
  input s_apb_penable;
  wire s_apb_penable;
  input [2:0] s_apb_pprot;
  wire [2:0] s_apb_pprot;
  input [2:0] s_apb_paddr;
  wire [2:0] s_apb_paddr;
  input [31:0] s_apb_pwdata;
  wire [31:0] s_apb_pwdata;
  input [3:0] s_apb_pstrb;
  wire [3:0] s_apb_pstrb;
  output s_apb_pready;
  wire s_apb_pready;
  output [31:0] s_apb_prdata;
  wire [31:0] s_apb_prdata;
  output s_apb_pslverr;
  wire s_apb_pslverr;
  wire _00_;
  wire _01_;
  wire _02_;
  wire _03_;
  wire _04_;
  wire _05_;
  wire _06_;
  wire [2:0] cpuif_addr;
  wire cpuif_rd_ack;
  wire [31:0] cpuif_rd_data;
  wire cpuif_rd_err;
  reg cpuif_req;
  reg cpuif_req_is_wr;
  wire cpuif_req_masked;
  wire cpuif_req_stall_rd;
  wire cpuif_req_stall_wr;
  wire cpuif_wr_ack;
  wire cpuif_wr_err;
  wire [0:0] decoded_reg_strb_r1;
  wire decoded_req;
  wire decoded_req_is_wr;
  reg is_active;
  wire [31:0] \readback_array[0] ;
  wire [31:0] readback_data;
  wire readback_done;
  wire readback_err;
  wire readback_external_rd_ack;
  always @(posedge clk)
    if (_01_) cpuif_req <= 1'h0;
    else if (s_apb_psel) cpuif_req <= 1'h1;
  always @(posedge clk)
    if (rst) cpuif_req_is_wr <= 1'h0;
    else if (_00_) cpuif_req_is_wr <= s_apb_pwrite;
  reg \cpuif_addr_reg[2] ;
  always @(posedge clk)
    if (rst) \cpuif_addr_reg[2]  <= 1'h0;
    else if (_00_) \cpuif_addr_reg[2]  <= s_apb_paddr[2];
  assign cpuif_addr[2] = \cpuif_addr_reg[2] ;
  always @(posedge clk)
    if (rst) is_active <= 1'h0;
    else is_active <= _06_;
  assign decoded_reg_strb_r1 = cpuif_req & _03_;
  assign cpuif_wr_ack = cpuif_req & cpuif_req_is_wr;
  assign cpuif_rd_ack = cpuif_req & _04_;
  assign _01_ = rst | is_active;
  assign _00_ = s_apb_psel & _02_;
  assign _03_ = ~cpuif_addr[2];
  assign _04_ = ~cpuif_req_is_wr;
  assign s_apb_pready = cpuif_rd_ack | cpuif_wr_ack;
  assign s_apb_prdata[4] = decoded_reg_strb_r1 & _04_;
  assign _05_ = ~s_apb_pready;
  assign _06_ = is_active ? _05_ : s_apb_psel;
  assign _02_ = ~is_active;
  assign cpuif_addr[1:0] = 2'h0;
  assign cpuif_rd_data = { 27'h0000000, s_apb_prdata[4], 3'h0, s_apb_prdata[4] };
  assign cpuif_rd_err = 1'h0;
  assign cpuif_req_masked = cpuif_req;
  assign cpuif_req_stall_rd = 1'h0;
  assign cpuif_req_stall_wr = 1'h0;
  assign cpuif_wr_err = 1'h0;
  assign decoded_req = cpuif_req;
  assign decoded_req_is_wr = cpuif_req_is_wr;
  assign \readback_array[0]  = { 27'h0000000, s_apb_prdata[4], 3'h0, s_apb_prdata[4] };
  assign readback_data = { 27'h0000000, s_apb_prdata[4], 3'h0, s_apb_prdata[4] };
  assign readback_done = cpuif_rd_ack;
  assign readback_err = 1'h0;
  assign readback_external_rd_ack = 1'h0;
  assign { s_apb_prdata[31:5], s_apb_prdata[3:0] } = { 30'h00000000, s_apb_prdata[4] };
  assign s_apb_pslverr = 1'h0;
endmodule
