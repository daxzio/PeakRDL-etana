"""
VHDL Wrapper Builder
Constructs the wrapper entity content
"""
import re
from typing import List, Tuple, Optional
from .vhdl_parser import VhdlPackageParser


class VhdlWrapperBuilder:
    """Builds the VHDL wrapper entity content"""

    def __init__(
        self,
        module_name: str,
        package_name: str,
        entity_content: str,
        parser: VhdlPackageParser,
        in_record_type: Optional[str],
        out_record_type: Optional[str],
    ):
        self.module_name = module_name
        self.package_name = package_name
        self.entity_content = entity_content
        self.parser = parser
        self.in_record_type = in_record_type
        self.out_record_type = out_record_type

        # Flatten the records
        self.in_signals = []
        self.out_signals = []

        if in_record_type:
            self.in_signals = parser.flatten_record(
                in_record_type, "hwif_in", "hwif_in"
            )
        if out_record_type:
            self.out_signals = parser.flatten_record(
                out_record_type, "hwif_out", "hwif_out"
            )

        # Extract non-hwif ports
        self.non_hwif_ports = self._extract_non_hwif_ports()

    def _extract_non_hwif_ports(self) -> List[str]:
        """Extract all ports except hwif_in and hwif_out"""
        ports = []

        # Find the port section in the entity - need to handle nested parens
        # Find 'port (' and then manually find the matching ')'
        port_start_match = re.search(
            r"entity\s+\w+\s+is\s+port\s*\(",
            self.entity_content,
            re.DOTALL | re.IGNORECASE,
        )

        if not port_start_match:
            return ports

        # Start after 'port ('
        start_pos = port_start_match.end()
        paren_depth = 1
        end_pos = start_pos

        # Find the matching closing parenthesis
        for i in range(start_pos, len(self.entity_content)):
            if self.entity_content[i] == "(":
                paren_depth += 1
            elif self.entity_content[i] == ")":
                paren_depth -= 1
                if paren_depth == 0:
                    end_pos = i
                    break

        if end_pos == start_pos:
            return ports

        port_section = self.entity_content[start_pos:end_pos]

        # Split by semicolon, keeping track of nested parentheses
        current_port = []
        paren_depth = 0

        for char in port_section:
            if char == "(":
                paren_depth += 1
                current_port.append(char)
            elif char == ")":
                paren_depth -= 1
                current_port.append(char)
            elif char == ";" and paren_depth == 0:
                # Found a port delimiter at the top level
                port_line = "".join(current_port).strip()
                if port_line and not port_line.startswith("--"):
                    # Skip hwif ports
                    if "hwif_in" not in port_line and "hwif_out" not in port_line:
                        ports.append(port_line)
                current_port = []
            else:
                current_port.append(char)

        # Handle last port (might not have trailing semicolon)
        if current_port:
            port_line = "".join(current_port).strip()
            if port_line and not port_line.startswith("--"):
                if "hwif_in" not in port_line and "hwif_out" not in port_line:
                    ports.append(port_line)

        return ports

    def generate(self) -> str:
        """Generate the complete wrapper entity content"""
        lines = []

        # Header
        lines.append("-- Generated by PeakRDL-regblock-vhdl HWIF Wrapper Tool")
        lines.append("--  https://github.com/SystemRDL/PeakRDL-regblock-vhdl")
        lines.append("--")
        lines.append(
            "-- This is a wrapper entity that flattens the hwif records into individual signals"
        )
        lines.append("")

        # Library and use clauses
        lines.append("library ieee;")
        lines.append("use ieee.std_logic_1164.all;")
        lines.append("use ieee.numeric_std.all;")
        lines.append("")
        lines.append(f"use work.{self.package_name}.all;")
        lines.append("")

        # Entity declaration
        lines.append(self._generate_entity_declaration())
        lines.append("")

        # Architecture
        lines.append(f"architecture wrapper of {self.module_name}_wrapper is")
        lines.append("")

        # Internal record signals
        lines.append(
            "    ----------------------------------------------------------------------------"
        )
        lines.append("    -- Internal hwif record signals")
        lines.append(
            "    ----------------------------------------------------------------------------"
        )

        if self.in_signals:
            lines.append(f"    signal hwif_in : {self.in_record_type};")
        if self.out_signals:
            lines.append(f"    signal hwif_out : {self.out_record_type};")
        lines.append("")

        lines.append("begin")
        lines.append("")

        # Flatten assignments
        lines.append(
            "    ----------------------------------------------------------------------------"
        )
        lines.append("    -- Flatten record to individual signals")
        lines.append(
            "    ----------------------------------------------------------------------------"
        )

        if self.in_signals:
            lines.extend(self._generate_input_assignments())
            lines.append("")

        if self.out_signals:
            lines.extend(self._generate_output_assignments())
            lines.append("")

        # Entity instantiation
        lines.append(
            "    ----------------------------------------------------------------------------"
        )
        lines.append("    -- Instantiate the main entity")
        lines.append(
            "    ----------------------------------------------------------------------------"
        )
        lines.append(self._generate_instance())
        lines.append("")

        lines.append(f"end architecture wrapper;")
        lines.append("")

        return "\n".join(lines)

    def _generate_entity_declaration(self) -> str:
        """Generate the entity declaration with flattened ports"""
        lines = []
        lines.append(f"entity {self.module_name}_wrapper is")
        lines.append("    port (")

        # Build port list
        ports = []

        # Copy all non-hwif ports
        for port in self.non_hwif_ports:
            ports.append(f"        {port};")

        # Add flattened hwif ports
        for signal_name, vhdl_type, direction, record_path in self.in_signals:
            port_decl = f"        {signal_name} : in {vhdl_type};"
            ports.append(port_decl)

        for signal_name, vhdl_type, direction, record_path in self.out_signals:
            port_decl = f"        {signal_name} : out {vhdl_type};"
            ports.append(port_decl)

        # Remove semicolon from last port
        if ports:
            ports[-1] = ports[-1].rstrip(";")

        lines.extend(ports)
        lines.append("    );")
        lines.append(f"end entity {self.module_name}_wrapper;")

        return "\n".join(lines)

    def _generate_input_assignments(self) -> List[str]:
        """Generate assignments from flattened inputs to record"""
        lines = []

        for signal_name, vhdl_type, direction, record_path in self.in_signals:
            # Generate assignment: hwif_in.path.to.field <= signal_name;
            lines.append(f"    {record_path} <= {signal_name};")

        return lines

    def _generate_output_assignments(self) -> List[str]:
        """Generate assignments from record to flattened outputs"""
        lines = []

        for signal_name, vhdl_type, direction, record_path in self.out_signals:
            # Generate assignment: signal_name <= hwif_out.path.to.field;
            lines.append(f"    {signal_name} <= {record_path};")

        return lines

    def _generate_instance(self) -> str:
        """Generate entity instantiation"""
        lines = []
        lines.append(f"    i_{self.module_name} : entity work.{self.module_name}")
        lines.append("        port map (")

        # Build port connections
        port_connections = []

        # Connect all non-hwif ports (pass-through)
        for port_decl in self.non_hwif_ports:
            # Extract port name from declaration
            # Format: <name> : in/out <type>
            # The name is the first word before the colon
            colon_pos = port_decl.find(":")
            if colon_pos > 0:
                port_name = port_decl[:colon_pos].strip()
                port_connections.append(f"            {port_name} => {port_name},")

        # Connect hwif ports to internal records
        if self.in_signals:
            port_connections.append("            hwif_in => hwif_in,")
        if self.out_signals:
            port_connections.append("            hwif_out => hwif_out,")

        # Remove comma from last connection
        if port_connections:
            port_connections[-1] = port_connections[-1].rstrip(",")

        lines.extend(port_connections)
        lines.append("        );")

        return "\n".join(lines)
