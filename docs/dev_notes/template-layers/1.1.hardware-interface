================================================================================
Summary
================================================================================

RTL interface that provides access to per-field context signals

**NOTE: This fork implements FLATTENED SIGNALS instead of structs**

This implementation uses individual signal ports for each hardware interface signal
instead of SystemVerilog structs. Each signal follows the naming pattern:
{direction}_{hierarchical_path}_{feature}

Examples:
- hwif_out_my_reg_my_field (field value output)
- hwif_in_my_reg_my_field_we (write enable input)
- hwif_in_user_signal (external signal input)

Regarding signals:
    RDL-declared signals are part of the flattened hwif inputs.
    Only include them if they are referenced by the design (need to scan the
    full design anyways, so may as well filter out unreferenced ones)

    It is possible to use signals declared in a parent scope.
    This means that not all signals will be discovered by a hierarchical listener alone
    Need to scan ALL assigned properties for signal references too.
        - get signal associated with top node's cpuif_reset helper property, if any
        - collect all field_resets
            X check all signal instances in the hier tree
            - search parents of top node for the first field_reset signal, if any
                This is WAY less expensive than querying EACH field's resetsignal property
        X Check all explicitly assigned properties
            only need to do this for fields
    Collect all of these into the following:
        - If inside the hier, add to a list of paths
        - if outside the hier, add to a dict of path:SignalNode
    These are all the signals in-use by the design

    Pass list into the hwif generator
        If the hwif generator encounters a signal during traversal:
            check if it exists in the signal path list

    out-of-hier signals are inserted as standalone flattened signals.
    Use their plain inst names with keyword filtering applied.
    Prefix with usersig_ if needed to avoid naming conflicts.


================================================================================
Naming Scheme (FLATTENED IMPLEMENTATION)
================================================================================

**Field Outputs:**
    hwif_out_my_regblock_my_reg_0_my_field (field value)
    hwif_out_my_regblock_my_reg_0_my_field_anded (reduction)

**Field Inputs:**
    hwif_in_my_regblock_my_reg_0_my_field (next value)
    hwif_in_my_regblock_my_reg_0_my_field_we (write enable)

**External Signals:**
    hwif_in_my_fieldreset_signal

**Register/Memory Signals:**
    hwif_out_my_mem_req
    hwif_in_my_mem_rd_ack

Array indices are flattened: my_reg[2] becomes my_reg_2

================================================================================
Flattened Implementation Details
================================================================================

**IMPLEMENTED**: This fork uses flattened signals throughout.

Key design decisions:
1. **Individual port declarations** - Each signal becomes a separate module port
2. **Hierarchical naming** - Path through design hierarchy becomes signal name
3. **Array flattening** - Array indices become part of signal name (reg_0, reg_1, etc.)
4. **MSB0 handling** - Bit swapping logic handles [low:high] fields transparently
5. **Width validation** - Added comprehensive width mismatch detection
6. **Signal filtering** - Only referenced signals are included in interface

Benefits of flattened approach:
- No SystemVerilog struct dependencies
- Better tool compatibility
- Easier debug and waveform viewing
- Direct signal connectivity
- Clearer signal tracing

Implementation files:
- src/peakrdl_etana/hwif/generators.py (InputLogicGenerator)
- src/peakrdl_etana/hwif/__init__.py (Hwif class)


================================================================================
IO Signals (FLATTENED)
================================================================================

Outputs:
    field value (hwif_out_*_*)
        If hw readable
    bitwise reductions (hwif_out_*_*_anded/ored/xored)
        if anded, ored, xored == True, output individual signals
    swmod/swacc (hwif_out_*_*_swmod/swacc)
        event strobes as individual signals

Inputs:
    field value (hwif_in_*_*)
        If hw writable
    we/wel (hwif_in_*_*_we/wel)
        if either is boolean, and true
        not part of external hwif if reference
        mutually exclusive
    hwclr/hwset (hwif_in_*_*_hwclr/hwset)
        if either is boolean, and true
        not part of external hwif if reference
    incr/decr (hwif_in_*_*_incr/decr)
        if counter=true, generate BOTH as individual signals
    incrvalue/decrvalue (hwif_in_*_*_incrvalue/decrvalue)
        if either incrwidth/decrwidth are set
    signals! (hwif_in_*)
        any signal instances instantiated in the scope as individual ports

================================================================================
Recent Enhancements
================================================================================

Applied fixes from upstream PeakRDL-regblock v1.1.0:
- Width mismatch detection in dereferencer
- Enhanced swmod byte strobe checking
- Write enable + sticky interrupt combinations
- Optimized single-bit stickybit logic
- RTL assertion guards for synthesis
- Reset logic improvements
